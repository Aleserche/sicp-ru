%\appendix
\chapter*{Литература}
\markboth{Литература}{Литература}
\addcontentsline{toc}{chapter}{Литература}
{
\parindent=0pt
\parskip=3mm
Abelson, Harold, Andrew Berlin, Jacob Katzenelson,
William McAllister,
Guiller\-mo Rozas, Gerald Jay Sussman, and Jack Wisdom. 1992.  The
Supercomputer Toolkit: A general framework for special-purpose
computing.  {\em International Journal of High-Speed Electronics}
3(3):337-361.

Allen, John.  1978.  {\em Anatomy of Lisp.} New York: McGraw-Hill.
                                                 
ANSI X3.226-1994. {\em American National Standard for Information
Sys\-tems---Pro\-g\-ram\-ming Language---Common Lisp.}

Appel, Andrew W.  1987.  Garbage collection can be faster than stack
allocation.  {\em Information Processing Letters} 25(4):275-279.

Backus, John.  1978.  Can programming be liberated from the von
Neumann style?  {\em Communications of the ACM} 21(8):613--641.%%!!!

Baker, Henry G., Jr.  1978.  List processing in real time on a serial
computer.  {\em Communications of the ACM} 21(4):280-293.

Batali, John, Neil Mayle, Howard Shrobe, Gerald Jay Sussman, and
Daniel Weise.  1982.  The Scheme-81 architecture---System and chip.
In {\em Proceedings of the MIT Conference on Advanced Research in
VLSI,} edited by Paul Penfield, Jr. Dedham, MA: Artech House.

Borning, Alan.  1977.  ThingLab---An object-oriented system for
building simula-ti\-ons using constraints. In {\em Proceedings of the 5th
International Joint Conference on Artificial Intelligence.}

Borodin, Alan, and Ian Munro.  1975.  {\em The Computational
Complexity of Algebraic and Numeric Problems.} New York: American
Elsevier.

Chaitin, Gregory J.  1975.  Randomness and mathematical proof.  
{\em Scientific Ame\-ri\-can} 232(5):47--52.

Church, Alonzo.  1941.  {\em The Calculi of Lambda-Conversion.}
Prin\-ce\-ton, N.J.: Prin\-ceton University Press.

Clark, Keith L.  1978.  Negation as failure.  In {\em Logic and Data
Bases.} New York: Plenum Press, pp. 293--322.

Clinger, William.  1982.  Nondeterministic call by need is neither
lazy nor by name. In {\em Proceedings of the ACM Symposium on Lisp and
Functional Programming,} pp. 226--234.

Clinger, William, and Jonathan Rees.  1991.  Macros that work.  In
{\em Proceedings of the 1991 ACM Conference on Principles of
Programming Languages,} pp. 155--162.

Colmerauer A., H. Kanoui, R. Pasero, and P. Roussel.  1973.  Un syst\`eme
de communication homme-machine en fran\c{c}ais.  Technical report,
Groupe Intelligence Artificielle, Universit\'e d'Aix Marseille,
Luminy.

Cormen, Thomas, Charles Leiserson, and Ronald Rivest.  1990. {\em
  Introduction to Algorithms.} Cam\-bridge, MA: MIT Press. (Русский
перевод: Кормен~Т., Ч.~Лейзерсон, Р.~Ривест.  Алгоритмы: построение и
анализ. -- М.: МЦНМО, 2001.)

Darlington, John, Peter Henderson, and David Turner.  1982.  
{\em Functional Pro\-gram\-ming and Its Applications.} New York: Cambridge
University Press.

Dijkstra, Edsger W. 1968a.  The structure of the ``THE''
multiprogramming system.  {\em Communications of the ACM}
11(5):341--346.

Dijkstra, Edsger W. 1968b.  Cooperating sequential processes.   
In {\em Programming Languages}, edited by F. Genuys. New York: Academic Press, 
pp. 43--112. (Русский перевод: Дийкстра~Э.  Взаимодействие последовательных
процессов. // в кн.: Языки программирования, под ред. Ф.~Женюи. -- М.:
Мир, 1972, с. 9--86.)

Dinesman, Howard P.  1968.  {\em Superior Mathematical Puzzles}.  New
York: Simon and Schuster.

deKleer, Johan, Jon Doyle, Guy Steele, and Gerald J. Sussman.  1977.
AMORD: Explicit control of reasoning.  In {\em Proceedings of the ACM
Symposium on Artificial Intelligence and Programming Languages,} pp.
116--125.

Doyle, Jon. 1979. A truth maintenance system. {\em Artificial
Intelligence} 12:231--272.

Feigenbaum, Edward, and Howard Shrobe. 1993. The Japanese National
Fifth Generation Project: Introduction, survey, and evaluation.  In {\em Future Generation Computer Systems,} vol. 9, pp. 105--117.

Feeley, Marc.  1986.  Deux approches \`a l'implantation du
language Scheme.  Masters thesis, Universit\'e de Montr\'eal.

Feeley, Marc and Guy Lapalme.  1987.  Using closures for code
generation.  {\em Journal of Computer Languages} 12(1):47--66.

Feller, William.  1957.  {\em An Introduction to Probability Theory
and Its Applications,} volume 1. New York: John Wiley \&
Sons. (Русский перевод: Феллер~В. Введение в теорию вероятностей и её
приложения, в 2-х томах. -- М.: Мир, 1984)

Fenichel, R., and J. Yochelson.  1969.  A Lisp garbage collector for
virtual memory computer systems.  {\em Communications of the ACM}
12(11):611--612.

Floyd, Robert. 1967. Nondeterministic algorithms. {\em JACM,} 14(4):636--644.

Forbus, Kenneth D., and Johan deKleer.  1993. {\em Building Problem
Solvers.} Cam\-bridge, MA: MIT Press.

Friedman, Daniel P., and David S. Wise.  1976.  CONS should not
evaluate its arguments. In {\em Automata, Languages, and Programming:
Third International Col\-loquium,} edited by S. Michaelson and R.
Milner, pp. 257--284.

Friedman, Daniel P., Mitchell Wand, and Christopher T. Haynes. 1992.
{\em Essentials of Programming Languages.}  Cambridge, MA: MIT
Press/McGraw-Hill.

Gabriel, Richard P. 1988.  The Why of {\em Y}.  {\em Lisp Pointers}
2(2):15--25.

Goldberg, Adele, and David Robson.  1983.  {\em Smalltalk-80: The
Language and Its Implementation.} Reading, MA: Addison-Wesley.

Gordon, Michael, Robin Milner, and Christopher Wadsworth.  1979.  {\em Edinburgh LCF.} Lecture Notes in Computer Science, volume 78. New
York: Springer-Verlag.

Gray, Jim, and Andreas Reuter. 1993. {\em Transaction Processing:
Concepts and Models.} San Mateo, CA: Morgan-Kaufman.

Green, Cordell.  1969.  Application of theorem proving to problem
solving.  In {\em Pro\-ceed\-ings of the International Joint Conference on
Artificial Intelligence,} pp. 219--240.

Green, Cordell, and Bertram Raphael.  1968.  The use of
theorem-proving tech\-niques in question-answering systems.  In {\em Proceedings of the ACM National Con\-fe\-rence,} pp. 169--181.

Griss, Martin L.  1981.  Portable Standard Lisp, a brief overview.
Utah Symbolic Computation Group Operating Note 58, University of Utah.

Guttag, John V.  1977.  Abstract data types and the development of
data structures.  {\em Communications of the ACM} 20(6):397--404.

Hamming, Richard W.  1980.  {\em Coding and Information Theory.}
Englewood Cliffs, N.J.: Prentice-Hall.

Hanson, Christopher P.  1990.  Efficient stack allocation for
tail-recursive languages.  In {\em Proceedings of ACM Conference on
Lisp and Functional Programming,} pp. 106--118.

Hanson, Christopher P.  1991.  A syntactic closures macro facility.
{\em Lisp Pointers,} 4(3).

Hardy, Godfrey H.  1921.  Srinivasa Ramanujan.  {\em Proceedings of
the London Ma\-the\-matical Society} XIX(2).

Hardy, Godfrey H., and E. M. Wright.  1960.  {\em An Introduction to
the Theory of Numbers.}  4th edition.  New York: Oxford University
Press.

Havender, J. 1968. Avoiding deadlocks in multi-tasking systems. {\em IBM Systems Journal} 7(2):74--84.

Hearn, Anthony C.  1969.  Standard Lisp.  Technical report AIM-90,
Artificial Intel\-li\-gence Project, Stanford University.

Henderson, Peter. 1980.  {\em Functional Programming: Application and
Imp\-le\-men\-ta\-tion.} Englewood Cliffs, N.J.: Prentice-Hall. (Русский
перевод: П.~Хендерсон. Функциональное программирование. -- М.: Мир, 1983.)

Henderson. Peter. 1982. Functional Geometry. In {\em Conference Record
of the 1982 ACM Symposium on Lisp and Functional Programming,}
pp. 179-187.

Hewitt, Carl E.  1969.  PLANNER: A language for proving theorems in
robots.  In {\em Proceedings of the International Joint Conference on
Artificial Intelligence,} pp. 295--301.

Hewitt, Carl E.  1977.  Viewing control structures as patterns of
passing messages.  {\em Journal of Artificial Intelligence}
8(3):323--364.

Hoare, C. A. R. 1972.  Proof of correctness of data representations.
{\em Acta Informa\-tica} 1(1).

Hodges, Andrew. 1983.  {\em Alan Turing: The Enigma.} New York: Simon
and Schuster.

Hofstadter, Douglas R.  1979.  {\em Gödel, Escher, Bach: An Eternal
Golden Braid.} New York: Basic Books. (Русский перевод: Хофштадтер~Д.
Гёдель, Эшер, Бах: эта бесконечная гирлянда. -- Самара: Бахрах, 2001.)

Hughes, R. J. M.  1990.  Why functional programming matters.  In {\em Research Topics in Functional Programming}, edited by David Turner.
Reading, MA: Addison-Wesley, pp. 17--42.

IEEE Std 1178-1990.  1990.  {\em IEEE Standard for the Scheme
Programming Lan\-gu\-age.}

Ingerman, Peter, Edgar Irons, Kirk Sattley, and Wallace Feurzeig;
assisted by M. Lind, Herbert Kanner, and Robert Floyd.  1960.  THUNKS:
A way of compiling procedure statements, with some comments on
procedure declarations.  Неопубликованная рукопись.  (А также частное
сообщение от Уоллеса Ферцейга.)

Kaldewaij, Anne. 1990.  {\em Programming: The Derivation of
Algorithms.} New York: Prentice-Hall.

Kohlbecker, Eugene Edmund, Jr. 1986.  Syntactic extensions in the
programming language Lisp.  Ph.D. thesis, Indiana University.

Konopasek, Milos, and Sundaresan Jayaraman.  1984.  {\em The TK!Solver
Book: A Guide to Problem-Solving in Science, Engineering, Business,
and Education.} Ber\-ke\-ley, CA: Osborne/McGraw-Hill.

Knuth, Donald E.  1973.  {\em Fundamental Algorithms.} Volume 1 of
{\em The Art of Compu\-ter Programming.}  2nd edition. Reading, MA:
Addison-Wesley. (Русский перевод: Кнут~Д. Искусство
программирования для ЭВМ. Т.~1.: Основные алгоритмы. -- СПб.: Вильямс, 2000.) 

Knuth, Donald E.  1981.  {\em Seminumerical Algorithms.} Volume 2 of
{\em The Art of Computer Programming.}  2nd edition. Reading, MA:
Addison-Wesley. (Русский перевод: Кнут~Д. Искусство
программирования для ЭВМ. Т.~2. Получисленные алгоритмы. -- СПб.: Вильямс, 2000.)

Kowalski, Robert.  1973.  Predicate logic as a programming language.
Technical report 70, Department of Computational Logic, School of
Artificial Intelligence, University of Edinburgh.

Kowalski, Robert.  1979.  {\em Logic for Problem Solving.} New York:
North-Holland. (Русский перевод: Ковальски Р. Логика в решении
проблем. -- М.: Наука, 1990.)

Lamport, Leslie. 1978.  Time, clocks, and the ordering of events in a
distributed system.  {\em Communications of the ACM} 21(7):558--565.

Lampson, Butler, J. J. Horning, R.  London, J. G. Mitchell, and G. K.
Popek.  1981.  Report on the programming language Euclid.  Technical
report, Computer Systems Research Group, University of Toronto.

Landin, Peter.  1965.  A correspondence between Algol 60 and Church's
lambda notation: Part I.  {\em Communications of the ACM}
8(2):89--101.

Lieberman, Henry, and Carl E. Hewitt. 1983. A real-time garbage
collector based on the lifetimes of objects. {\em Communications of
the ACM} 26(6):419--429.

Liskov, Barbara H., and Stephen N. Zilles.  1975.  Specification
techniques for data abstractions.  {\em IEEE Transactions on Software
Engineering} 1(1):7--19.

McAllester, David Allen.  1978.  A three-valued truth-maintenance
system.  Memo 473, MIT Artificial Intelligence Laboratory.

McAllester, David Allen.  1980.  An outlook on truth maintenance.
Memo 551, MIT Artificial Intelligence Laboratory.

McCarthy, John.  1960.  Recursive functions of symbolic expressions
and their computation by machine.  {\em Communications of the ACM}
3(4):184--195.

McCarthy, John.  1967.  A basis for a mathematical theory of
computation.  In {\em Computer Programing and Formal Systems}, edited
by P. Braffort and D. Hirsch\-berg.  North-Holland.

McCarthy, John.  1978.  The history of Lisp.  In {\em Proceedings of
the ACM SIGPLAN Conference on the History of Programming Languages.}

McCarthy, John, P. W. Abrahams, D. J. Edwards, T. P. Hart, and M. I.
Levin.  1965.  {\em Lisp 1.5 Programmer's Manual.}  2nd edition.
Cambridge, MA: MIT Press.

McDermott, Drew, and Gerald Jay Sussman.  1972. Conniver reference
manual.  Memo 259, MIT Artificial Intelligence Laboratory.

Miller, Gary L.  1976.  Riemann's Hypothesis and tests for primality.
{\em Journal of Computer and System Sciences} 13(3):300--317.

Miller, James S., and Guillermo J. Rozas. 1994.  Garbage collection is
fast, but a stack is faster.  Memo 1462, MIT Artificial Intelligence
Laboratory.

Moon, David.  1978.  MacLisp reference manual, Version 0.  Technical
report, MIT Laboratory for Computer Science.

Moon, David, and Daniel Weinreb.  1981.  Lisp machine manual.
Technical report, MIT Artificial Intelligence Laboratory.

Morris, J. H., Eric Schmidt, and Philip Wadler.  1980.  Experience
with an ap\-pli\-ca\-tive string processing language.  In {\em Proceedings
of the 7th Annual ACM SIGACT/SIGPLAN Symposium on the Principles of
Programming Languages.}

Phillips, Hubert.  1934. {\em The Sphinx Problem Book}.  London: Faber
and Faber.

Pitman, Kent.  1983.  The revised MacLisp Manual (Saturday evening
edition).  Technical report 295, MIT Laboratory for Computer Science.

Rabin, Michael O. 1980. Probabilistic algorithm for testing primality.
{\em Journal of Number Theory} 12:128--138.

Raymond, Eric.  1993. {\em The New Hacker's Dictionary.} 2nd edition.
Cambridge, MA: MIT Press. (Русский перевод: Рэймонд Э.  Новый словарь
хакера. -- М.: ЦентрКом, 1996.)

Raynal, Michel. 1986. {\em Algorithms for Mutual Exclusion.}
Cambridge, MA: MIT Press.

Rees, Jonathan A., and Norman I. Adams IV. 1982.  T: A dialect of Lisp
or, lambda: The ultimate software tool.  In {\em Conference Record of
the 1982 ACM Symposium on Lisp and Functional Programming,} pp.
114--122.

Rees, Jonathan, and William Clinger (eds). 1991.  The revised$^4$
report on the algorithmic language Scheme.  {\em Lisp Pointers,} 4(3).

Rivest, Ronald, Adi Shamir, and Leonard Adleman.  1977.  A method for
obtaining digital signatures and public-key cryptosystems. Technical
memo LCS/TM82, MIT Laboratory for Computer Science.

Robinson, J. A. 1965.  A machine-oriented logic based on the
resolution principle.  {\em Journal of the ACM} 12(1):23.

Robinson, J. A. 1983.  Logic programming---Past, present, and future.
{\em New Ge\-ne\-ra\-tion Computing} 1:107--124. (Русский перевод:
Робинсон~Дж.  Логическое программирование -- прошлое, настоящее и
будущее.  // В кн. Логическое программирование. -- М.: Мир, 1988, с. 7--26.)

Spafford, Eugene H.  1989.  The Internet Worm: Crisis and aftermath.
{\em Com\-mu\-ni\-ca\-tions of the ACM} 32(6):678--688.

Steele, Guy Lewis, Jr.  1977.  Debunking the ``expensive procedure
call'' myth.  In {\em Proceedings of the National Conference of the
ACM,} pp. 153--62.

Steele, Guy Lewis, Jr.  1982.  An overview of Common Lisp.  In {\em Proceedings of the ACM Symposium on Lisp and Functional Programming,}
pp. 98--107.

Steele, Guy Lewis, Jr.  1990.  {\em Common Lisp: The Language.} 2nd
edition.  Digital Press.

Steele, Guy Lewis, Jr., and Gerald Jay Sussman.  1975.  Scheme: An
interpreter for the extended lambda calculus.  Memo 349, MIT
Artificial Intelligence Laboratory.

Steele, Guy Lewis, Jr., Donald R. Woods, Raphael A. Finkel, Mark R.
Crispin, Richard M. Stallman, and Geoffrey S. Goodfellow.  1983.  {\em The Hacker's Dictionary.} New York: Harper \& Row.

Stoy, Joseph E.  1977.  {\em Denotational Semantics.} Cambridge, MA:
MIT Press.

Sussman, Gerald Jay, and Richard M. Stallman.  1975.  Heuristic
techniques in computer-aided circuit analysis.  {\em IEEE Transactions
on Circuits and Systems} CAS-22(11):857--865.

Sussman, Gerald Jay, and Guy Lewis Steele Jr.  1980.  Constraints -- A
language for expressing almost-hierachical descriptions.  {\em AI
Journal} 14:1--39.

Sussman, Gerald Jay, and Jack Wisdom.  1992. Chaotic evolution of the
solar system.  {\em Science} 257:256-262.

Sussman, Gerald Jay, Terry Winograd, and Eugene Charniak.  1971.
Microplanner reference manual.  Memo 203A, MIT Artificial Intelligence
Laboratory.

Sutherland, Ivan E.  1963.  SKETCHPAD: A man-machine graphical
communica\-tion system.  Technical report 296, MIT Lincoln Laboratory.

Teitelman, Warren.  1974.  Interlisp reference manual.  Technical
report, Xerox Palo Alto Research Center.

Thatcher, James W., Eric G. Wagner, and Jesse B. Wright. 1978.
Data type specification: Parameterization and the power of
specification techniques. In {\em Con\-fe\-rence Record of the Tenth Annual ACM
Symposium on Theory of Computing}, pp. 119--132.

Turner, David.  1981.  The future of applicative languages.  In {\em Proceedings of the 3rd European Conference on Informatics,} Lecture
Notes in Computer Science, volume 123. New York: Springer-Verlag, pp.
334--348.

Wand, Mitchell.  1980.  Continuation-based program transformation
stra\-te\-gies.  {\em Jour\-nal of the ACM} 27(1):164--180.

Waters, Richard C.  1979.  A method for analyzing loop programs.  
{\em IEEE Trans\-ac\-tions on Software Engineering} 5(3):237--247.

Winograd, Terry.  1971.  Procedures as a representation for data in a
computer program for understanding natural language.  Technical report
AI TR-17, MIT Artificial Intelligence Laboratory.

Winston, Patrick. 1992. {\em Artificial Intelligence}.  3rd edition.
Reading, MA: Addison-Wesley.

Zabih, Ramin, David McAllester, and David Chapman.  1987.
Non-deterministic Lisp with dependency-directed backtracking.
{\em AAAI-87}, pp. 59--64.

Zippel, Richard.  1979.  Probabilistic algorithms for sparse
polynomials.  Ph.D. dis\-ser\-ta\-tion, Department of Electrical Engineering
and Computer Science, MIT.

Zippel, Richard.  1993.  {\em Effective Polynomial Computation.}
Boston, MA: Kluwer Academic Publishers.
}
