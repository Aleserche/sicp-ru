\chapter*{Предисловие}
\markboth{Предисловие}{Предисловие} %% Снять "Алана Перлиса"
\addcontentsline{toc}{chapter}{Предисловие}
\thispagestyle{empty}
%Алан Дж. Перлис, Нью Хэйвен, Коннектикут

Программированием занимаются учителя, генералы, диетологи, психологи и родители.
Программированию подвергаются армии, ученики и некоторые виды обществ.
При решении крупных задач приходится применять последовательно множество
программ, б\'ольшая часть которых возникает прямо в процессе решения.
Эти программы изобилуют деталями, относящимися к той конкретной задаче,
которую они решают. Если же Вы хотите
оценить программирование как интеллектуальную деятельность особого
рода, то Вам следует обратиться к программированию компьютеров; читайте и пишите
компьютерные программы~--- много программ. Не так уж важно, что будет в них написано и
как они будут применяться.  Важно то,
насколько хорошо они работают и как гладко
стыкуются с другими программами при создании еще более крупных
программ. Программист должен равно стремиться и к совершенству в деталях, и
к соразмерности сложного целого. В книге, которую Вы держите в руках, словом <<программирование>>
мы будем обозначать прежде всего создание, выполнение и изучение программ,
написанных на одном из диалектов языка Лисп и предназначенных для выполнения на цифровом
компьютере. Использование Лиспа не ограничивает нас в том, чт\'о мы можем
описать в наших программах,~--- лишь в способе их выражения.

Продвигаясь по материалу этой книги, мы будем встречаться с тремя
группами явлений: человеческий разум, совокупности компьютерных программ и 
компьютер. Всякая компьютерная программа~--- это порожденная
человеческим разумом модель реального либо умозрительного
процесса. Эти процессы, возникающие из нашего опыта и мысли,
многочисленны, сложны в деталях, и мы всегда понимаем их лишь
частично.  Редко бывает так, что компьютерные программы
отображают их к нашему окончательному удовлетворению. Таким образом, хотя наши
программы представляют собой тщательно сработанные дискретные совокупности 
символов, мозаики переплетенных функций, они непрерывно развиваются: мы
изменяем их по мере того, как наше восприятие модели приобретает все
большую глубину, расширяется и обобщается, до тех пор, пока модель не достигнет,
наконец, метастабильного состояния в рамках следующей модели, над
которой нам предстоит биться.  Радостное возбуждение, сопутствующее
компьютерному программированию, происходит из постоянного раскрытия в
голове и в 
компьютере все новых выраженных в виде программ механизмов и из взрыва восприятия, 
который они порождают.  Искусство выражает наши мечты.
Компьютер исполняет их под видом программ!

При всей своей мощности, компьютер требователен и придирчив.
Ему нужны верные программы, и то, что мы хотим ему
сказать, должно быть выражено точно в каждой мелочи.  Как и при всякой
другой работе с символами, мы убеждаемся в правильности программ
через доказательство.  Самому Лиспу можно сопоставить семантику
(между прочим, тоже модель), и если функцию программы можно
выразить, скажем, в терминах исчисления предикатов, то логические
методы позволят нам вывести формальное доказательство ее
корректности.  К сожалению, когда программы становятся большими и
сложными, что с ними всегда и происходит, адекватность,
непротиворечивость и корректность самих спецификаций становится
предметом сомнений, так что большие программы редко сопровождаются
полными формальными доказательствами корректности. Поскольку большие
программы вырастают из малых, нам необходимо обзавестись арсеналом
программных структур,  в правильности которых мы можем быть уверены~---
их можно назвать идиомами~--- и научиться объединять их в структуры 
большего размера с помощью организационных методов, ценность которых
также доказана. Эти методы подробно обсуждаются в книге, и их
понимание существенно для участия в прометеевском предприятии под
названием <<программирование>>. Для умения создавать большие,
значительные программы нет лучшего помощника, чем свободное владение
мощными организационными методами.  И наоборот: затраты, связанные с написанием больших программ,
побуждают нас изобретать новые методы уменьшения веса функций и 
деталей, входящих в эти программы.


В отличие от программ, компьютеры должны повиноваться законам 
физики. Если мы хотим, чтобы они работали быстро~--- по нескольку наносекунд на
смену состояния,~--- электроны в их цепях не должны проходить большие
расстояния (более полуметра). При этом тесно сконцентрированные в
пространстве приборы излучают тепло, которое нужно куда-то
отводить: так развилось изысканное инженерное искусство,
призванное находить равновесие между обилием функций и плотностью
расположения устройств. Так или иначе, аппаратура всегда работает
ниже того уровня, на котором мы бы хотели программировать. Процессы,
посредством которых наши программы на Лиспе переводятся в <<машинные>>
программы, сами являются абстрактными моделями, которые мы воплощаем в
программах. Их 
изучение и реализация многое дают для понимания организационных методов, 
направленных на программирование произвольных моделей.  Разумеется, так
можно смоделировать и сам компьютер. Подумайте об этом: поведение
мельчайшего переключателя моделируется квантовой механикой, которая
описывается дифференциальными уравнениями, точное поведение которых
фиксируется в численных приближениях, представленных в виде
компьютерных программ, которые выполняются на компьютере, составленном
из~...~--- и так без конца!

Раздельное выделение трех групп явлений --- не просто вопрос
тактического удобства.  Хотя эти группы и остаются, как говорится, в голове,
но, проводя это разделение, мы позволяем потоку символов между тремя группами
двигаться быстрее.  В человеческом опыте с этим потоком по богатству, живости и
обилию возможностей сравнится разве что сама эволюция жизни. Отношения
между разумом человека, программами и компьютером в лучшем случае
метастабильны.  Компьютерам никогда не хватает мощности и быстродействия.  Каждый новый прорыв в
технологии производства аппаратуры ведет к появлению более масштабных
программных проектов, новых организационных принципов и к обогащению
абстрактных моделей.  Пусть каждый читатель время от времени
спрашивает себя: <<А зачем, к чему все это?>>~--- только не слишком
часто, чтобы удовольствие от программирования не сменилось горечью
философского тупика.

\pagebreak

Из тех программ, которые мы пишем, некоторые (но всегда
меньше, чем хотелось бы) решают точные математические задачи, такие, как
сортировка последовательности чисел или нахождение их максимума,
проверка числа на простоту или вычисление квадратного корня.  Такие
программы называются алгоритмами, и об их оптимальном
поведении известно довольно много, особенно в том, что касается двух
важных параметров: времени выполнения и потребления памяти.  
Программист должен владеть хорошими алгоритмами и идиомами.  
Несмотря на то, что некоторые программы	сопротивляются точной спецификации, 
в обязанности программиста входит оценивать их производительность и все 
время пытаться ее улучшить.

Лисп --- ветеран, он используется уже около четверти века.
Среди живых языков программирования старше него только Фортран.  Эти два языка
обслуживали нужды важных прикладных областей: Фортран~--- естественно-научных и
технических вычислений, а Лисп~--- искусственного интеллекта. Обе эти
области по-прежнему важны, а программисты, работающие в них, настолько привязаны к
этим двум языкам, что Лисп и Фортран вполне могут остаться в деле еще по
крайней мере на четверть столетия.

Лисп изменяется. Scheme, его диалект, используемый в этой
книге, развился из первоначального Лиспа и отличается от него в
некоторых важных отношениях: в частности, используются статические области связывания
переменных, а функции могут возвращать в качестве значений другие 
функции. По семантической структуре Scheme так же близка к Алголу 60,
как и к ранним вариантам Лиспа.  Алгол 60, который уже никогда не будет живым
языком, продолжает жить в генах Scheme и Паскаля.  Пожалуй, трудно
найти две более разные культуры программирования, чем те, что
образовались вокруг этих двух языков и используют их в качестве
единой валюты.  Паскаль служит для построения 
пирамид~--- впечатляющих, захватывающих статических структур,
создаваемых армиями, которые укладывают на места тяжелые плиты.  При
помощи Лиспа порождаются организмы~--- впечатляющие, захватывающие
динамические структуры, создаваемые командами, которые собирают их из
мерцающих мириад более простых организмов.  Организующие принципы в
обоих случаях остаются одни и те же, за одним существенным исключением:
программист, пишущий на Лиспе, располагает на порядок большей творческой свободой
в том, что касается функций, которые он создает для использования
другими. Программы на Лиспе населяют библиотеки функциями, которые
оказываются настолько полезными, что они переживают породившие их приложения.  Таким
ростом полезности мы во многом обязаны списку~--- исконной лисповской
структуре данных.  Простота структуры списков и естественность их
использования отражаются в удивительной общности функций.  В Паскале обилие объявляемых структур 
данных ведет к специализации функций, которая сдерживает и наказывает
случайное взаимодействие между ними.  Лучше иметь 100 функций, которые работают с одной
структурой данных, чем 10 функций, работающих с 10
структурами. В результате пирамиде приходится неподвижно стоять
тысячелетиями; организм же будет развиваться или погибнет.

	Чтобы увидеть эту разницу, сравните подачу
материала и упражнения в этой книге с тем, что Вы найдете в любом
вводном тексте, авторы которого используют Паскаль. Не поддавайтесь
ошибочному впечатлению, будто этот текст может усвоить лишь студент MIT~--- представитель
специфической породы, которая только там и встречается.   Нет; именно
такова должна быть всякая серьезная книга, посвященная
программированию на Лиспе, вне зависимости от того, где и кто по ней
учится.

	Учтите, что это текст о программировании, в отличие от
большинства книг по Лиспу, которые используются для подготовки
работников в области искусственного интеллекта.  В конце концов, основные
программистские заботы вычислительной инженерии и искусственного
интеллекта стремятся к взаимопроникновению по мере того, как соответствующие
системы увеличиваются в объеме.  Это объясняет рост интереса к
Лиспу за пределами искусственного интеллекта.

	Как и можно было ожидать, глядя на цели, которые ставят перед
собой исследователи в области искусственного интеллекта, область эта
порождает множество значительных 
программистских задач.  В других программистских культурах такой
наплыв задач рождает новые языки.  В самом деле, в любой
большой программной задаче один из важных принципов организации	
состоит в том, чтобы  ограничить и изолировать потоки информации в отдельных
модулях задачи, изобретая для этого язык.  По мере приближения к
границам системы, где мы~--- люди~---
взаимодействуем чаще всего, эти языки обычно становятся все менее
примитивными.  В результате такие системы содержат сложные функции по
обработке языка, повторенные по многу раз.  У Лиспа же синтаксис и
семантика настолько просты, что синтаксический разбор можно считать 
элементарной задачей.  Таким образом, методы синтаксического
разбора не играют почти никакой роли в программах на Лиспе, и
построение языковых процессоров редко служит препятствием для роста и
изменения больших Лисп-систем.  Наконец, именно эта простота
синтаксиса и семантики возлагает бремя свободы на всех 
программистов на Лиспе.  Никакую программу на Лиспе больше, чем 
в несколько строк длиной, невозможно написать, не населив ее
самостоятельными функциями.  Находите новое и приспосабливайте; складывайте и
стройте новыми способами!  Я поднимаю
тост за программиста на Лиспе, укладывающего свои мысли в гнезда скобок.

\par\bigskip
{\parindent=0cm
Алан Дж. Перлис \\
Нью-Хейвен, Коннектикут}
